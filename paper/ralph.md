# Introduction

Ralph is a software-engineering agent technique that replaces one-off AI coding calls with a persistent execution loop. The core idea is to repeatedly run Codex on the same task until a completion condition is satisfied, while preserving repository state between iterations. Geoffrey Huntley framed this as the essential pattern: a Bash loop that pipes a fixed task prompt repeatedly into an agent until completion.

The Codex execution kernel used in this document is:

`for i in {1..5}; do cat PROMPT.md | codex exec --dangerously-bypass-approvals-and-sandbox -; done`

This Codex command is a bounded adaptation of the loop framing in Huntley’s post (published July 2025). Huntley characterizes the loop as intentionally robust through repeated deterministic correction in an uncertain world, and reports community experiments that claim sustained overnight behavior in hackathon settings.

This document treats Ralph as a family of loop patterns, but standardizes execution on Codex only. The ecosystem patterns we reuse include:

- Pure Bash loops inspired by the original pattern.
- Community CLI implementations that externalize loop state.
- Explicit verifier-driven loops around repeated agent execution.

Together these forms share the same thesis: **stable outer loop + explicit completion signal + persistent external state** is more reliable than a single-shot generation attempt for many implementation tasks.

# Task Formulation

Given a fixed prompt `p` and persisted work state `s_t` at iteration `t`, one Ralph-style step can be expressed as:

`a_t = agent(p, s_t)`

The platform applies tools/actions and mutates repository-relevant artifacts, producing next state:

`s_{t+1} = T(s_t, a_t)`

An acceptance predicate `C(s_t)` determines whether the goal is met. The loop continues until:

`C(s_t) == true` or an external stop condition `S` (max iterations, cost, or manual cancel) becomes true.

In practice, `s_t` is not a hidden scratchpad. It is explicit: changed files, git commits, status files, and logs. This is important because all non-trivial implementations avoid depending on unlimited conversational memory.

The completion signal can be implemented in different ways:

- Explicit marker in agent output (for example `<promise>COMPLETE</promise>`).
- A verifier function that checks tests, structural conditions, or artifact presence.
- A combination of explicit marker + guardrails.

# Methodology

## Core Loop

All implementations can be represented by:

```text
initialize state s0
for t = 1 to limit or until done:
  output = run_agent(prompt, s_t)
  write output/artifacts into repository
  if complete(output, artifacts, s_t):
      break
  update persistent state logs
  prepare for next iteration
end
```

This is run by external process control (a bounded shell loop) that repeatedly invokes `codex exec` with the same prompt and repository state.

## State channels

Across ecosystems, persisted state is the convergence backbone.

- **Repository filesystem**: source files, generated artifacts, migration scripts, documentation.
- **Version control history**: commit history used as durable progress memory.
- **Task metadata**: PRD/story files, statuses, iteration counters, and completion flags.
- **Progress logs**: append-only notes, errors, rationale for retries.

Notable concrete patterns:

- `prd.json` + `progress.txt` (snarktank community implementation).
- `.ralph/` with `progress.md`, `activity.log`, `errors.log` (iannuttall implementation).
- Iteration-level artifacts generated by each Codex run (for example tests, logs, and commit metadata).

## Prompt contract

The loop is only as strong as its contract. Strong prompts typically specify:

- Objective and scope.
- Concrete completion criteria (tests, files, behavior).
- Explicit completion promise text if using string matching.
- Iteration boundaries and fallback actions after repeated failures.

Open-source implementations commonly require a deterministic exit signal style for loop control. A mismatch here is the most frequent practical failure mode.

# Core Implementations

## Geoffrey Huntley / Origin

The earliest influential public articulation treats Ralph as a minimal shell loop. In the published form, the same task prompt is continuously fed to a local coding agent, with no inherent built-in cap unless wrapped by shell control. Huntley frames this as a general method, and this document executes that method with Codex only:

- loop form: repeated execution of one command line against a fixed prompt.
- completion: convention in prompt text, often via explicit marker.
- state: repository + history + user-owned logs.

The origin framing emphasizes simplicity and transferability; here, transferability is intentionally narrowed to one runner for operational consistency.

## Codex execution template

The standard loop form is:

`for i in {1..5}; do cat PROMPT.md | codex exec --dangerously-bypass-approvals-and-sandbox -; done`

Execution properties:

- fixed prompt contract from `PROMPT.md`,
- bounded retries (`1..5`) to prevent runaway loops,
- fresh process invocation per iteration,
- explicit completion and verification checks in prompt/test steps.

## Community and CLI patterns (Codex-only adaptation)

### snarktank/ralph pattern reuse

`snarktank/ralph` contributes a practical state layout pattern that can be reused with Codex execution:

- shell runner script with max-iteration control,
- prompt template files,
- `prd.json` task state with story pass flags.
- `progress.txt` append-only learnings.

Loop behavior:

- picks highest-priority unfinished user story,
- runs one story per iteration,
- runs checks and commits if green,
- records progress and marks story completion,
- repeats until all stories pass or limit reached.

In this Codex-only variant, each iteration executes via `codex exec` rather than multi-runner dispatch.

### iannuttall/ralph pattern reuse

`iannuttall/ralph` contributes useful status and template organization for Codex workflows. It standardizes state under `.ralph/` and separates task status transitions through a small finite-state representation:

- `open`
- `in_progress`
- `done`

In this document’s execution policy, runner choice is not pluggable: execution is pinned to Codex only.

## Comparative matrix across Codex execution patterns

| Dimension | Minimal Codex loop | snarktank-style Codex wrapper | iannuttall-style Codex wrapper |
|---|---|---|---|
| Control location | External shell | External shell script | External CLI process |
| Completion signal | Prompt convention + checks | Story completion + checks | Status transitions + checks |
| State storage | Repo + git | `prd.json`, `progress.txt`, git | `.ralph/` templates + git |
| Default stopping behavior | Explicitly bounded (`1..5`) | Bounded by script arguments | Bounded by command/config settings |
| Safety controls | Loop bound + test gates | Loop bound + explicit checks | Runner policy + visibility commands |
| Typical use case | Fast deterministic retries | Structured story execution | Reusable team workflow templates |

# Exit Conditions and Safety Controls

Three control layers recur across all implementations:

1. **Positive completion**: explicit promise, verifier function, or story completion checks.
2. **Hard bound**: max iteration count, time/usage bound, or staged retries.
3. **Manual abort**: command-level cancel or user interruption.

Safety is implementation-dependent and mostly absent by default in the origin pattern; most modern variants add explicit caps. Prompt-only exits are fragile when the phrase drifts, so exact completion strings should be stable and unambiguous.

# Experimental / observational evidence

At the time of writing, no formal peer-reviewed benchmark exists for autonomous coding loop quality. Available evidence is primarily field anecdote and adoption signals:

- Huntley-style reports describe overnight repository shipping under constrained loop execution.
- Public sharing of Codex loop runbooks indicates sustained usage interest in bounded autonomous execution.
- Independent community implementations report practical uptake (GitHub stars, fork activity) and provide runbooks for local workflows.

A key caveat: these are **non-comparable, non-randomized, operational anecdotes**. They are useful for operator expectations but should not be interpreted as measured causal performance claims.

# Discussion

### Why fresh context resets work

Some ecosystems intentionally run each iteration in a fresh context, which avoids unbounded conversational growth and can stabilize behavior for long tasks. This supports clear handoff and repeatability, especially when the model can read accumulated edits from the filesystem.

### Why externalized state is central

Ralph variants are durable because they do not rely on transient model memory. Git history and explicit status files become the true context source. That allows failed attempts to become recoverable signals, not just discarded errors.

### Trade-off versus single-shot prompting

Single-shot prompts can be faster for one-hop edits, but they often stop at first pass and never close multi-step loops. Ralph-style designs provide persistence and correction but increase iteration cost, require stronger guardrails, and depend on good completion criteria.

# Limitations and Future Directions

Current limitations across the ecosystem include:

- **Runaway autonomy risk**: loops can consume budget or time without progress if completion predicates are weak.
- **Completion fragility**: exact-string promises can fail on formatting drift.
- **Verifier quality**: quality depends on the reliability of downstream checks and tests.
- **Context reuse ambiguity**: some workflows preserve too much prior state across iterations, while strict shell-loop resets can be too loose without explicit policy.

Future work directions include:

- richer multi-signal completion policies (test pass + static checks + semantic checks),
- adaptive stop policies across token, cost, and failure-rate dimensions,
- stronger safety patterns for destructive commands in autonomous loops,
- shared schema for story/task state and verifier interfaces across implementations.

# References

- Geoffrey Huntley (2025). *Ralph Wiggum as a "software engineer"*. https://ghuntley.com/ralph/
- snarktank. (2025). *Ralph* repository and loop script implementation. https://github.com/snarktank/ralph
- iannuttall. *Ralph* CLI implementation. https://github.com/iannuttall/ralph
